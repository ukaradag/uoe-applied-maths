# STATS PROG PRACTICAL 3
# UZAY KARADAG S2592749

# Define eta function for global use in the functions
eta <- function(r) { if (r > 0) { return(r^2 * log(r)) } else { return(0) } }

getTPS <- function(x, k = 100) {
  # Function: getTPS
  # Purpose: This function computes the Thin Plate Spline (TPS) interpolation matrices.
  # Parameters:
  # - x: A matrix of input data points (rows are observations, columns are dimensions).
  # - k: An integer specifying the number of rows to randomly sample from x.
  # Returns:
  # - A list containing four elements:
  #   - xk: The k randomly sampled rows from x.
  #   - X: The joint matrix of E*Z and T.
  #   - S: The S matrix which includes Zt_Ek_Z and padding of zeros.
  #   - Z: Matrix Z computed using the QR decomposition of Tk.

  # Validate n vs. k and sample xk
  n <- nrow(x)
  if (k >= n) { k <- n
    xk <- x } else {
    # Randomly Sample k Rows from x
    xk <- x[sample(1:n, k),] }

  # Define Vectorized eta_j Function
  eta_j_vectorized <- function(X, xk_row) { distances <- apply(X, 1, function(x) norm(x - xk_row, '2'))
    return(sapply(distances, eta)) }

  # Calculate Ek Matrix Using Vectorized eta_j function
  fill_Ek <- function(i, j) { eta_j_vectorized(matrix(xk[i,], nrow = 1), xk[j,]) }

  Ek <- outer(seq_len(nrow(xk)), seq_len(nrow(xk)), Vectorize(fill_Ek))

  # Calculate E Matrix Using Vectorized eta_j function
  fill_E <- function(i, j) { eta_j_vectorized(matrix(x[i,], nrow = 1), xk[j,]) }

  E <- outer(seq_len(nrow(x)), seq_len(nrow(xk)), Vectorize(fill_E))

  # Construct T and Tk Matrices
  T <- cbind(1, x)
  Tk <- cbind(1, xk)

  # Compute Z Matrix Using QR Decomposition
  Z <- qr.Q(qr(Tk), complete = TRUE)[, -(1:3)]

  # Compute X Matrix
  EZ <- E %*% Z
  X <- cbind(EZ, T)

  # Compute S Matrix and Adjust Dimensions
  Zt_Ek_Z <- t(Z) %*% Ek %*% Z
  num_zero_cols <- nrow(xk) - ncol(Zt_Ek_Z)
  num_zero_rows <- nrow(xk) - nrow(Zt_Ek_Z)
  zc <- matrix(0, nrow = nrow(Zt_Ek_Z), ncol = num_zero_cols)
  zr <- matrix(0, nrow = num_zero_rows, ncol = nrow(xk))
  S <- rbind(cbind(Zt_Ek_Z, zc), zr)

  # Return Results as a List
  return(list(xk = xk, X = X, S = S, Z = Z)) }


# Create mock data for testing
ff <- function(x) exp(-(x[, 1] - .3)^2 / .2^2 - (x[, 2] - .3)^2 / .3^2) * .5 + exp(-(x[, 1] - .7)^2 / .25^2 - (x[, 2] - .8)^2 / .3^2)

n <- 500
x <- matrix(runif(n * 2), n, 2)
k <- 100
y <- ff(x)

lsp <- c(-5, 5)

fitTPS <- function(x, y, k = 100, lsp = c(-5, 5)) {
  # Function: fitTPS
  # Purpose: Fit Thin Plate Splines (TPS) to x, y data, and choose the smoothing parameter by GCV.
  # Parameters:
  # - x: n x 2 matrix of input data points.
  # - y: n-length vector of output data points.
  # - k: basis size.
  # - lsp: Range of log-smoothing parameters.
  # Returns:
  # A list containing beta, mu, medf, lambda, gcv, edf.

  # Get TPS matrices
  res_get <- getTPS(x, k)

  X <- res_get$X
  S <- res_get$S

  # QR decomposition
  qr_X <- qr(X)
  Q <- qr.Q(qr_X)
  R <- qr.R(qr_X)
  R_inv <- solve(R)

  # Symmetric eigen decomposition
  sed <- eigen(t(R_inv) %*% S %*% R_inv, symmetric = TRUE)
  U <- sed$vectors
  Lambda <- diag(sed$values)

  # Initialize variables for GCV optimization
  min_gcv <- Inf
  optimal_lambda <- NA
  n <- nrow(x)

  # Loop over lambda candidates
  for (log_lambda in seq(lsp[1], lsp[2], length.out = 100)) { lambda <- exp(log_lambda)
    # EDF and Beta calculations
    inv_I_lambda_Lambda <- solve(diag(100) + lambda * Lambda)
    EDF <- sum(inv_I_lambda_Lambda)
    Beta <- R_inv %*%
      U %*%
      inv_I_lambda_Lambda %*%
      t(U) %*%
      t(Q) %*%
      y

    # GCV calculation
    mu <- X %*% Beta
    gcv <- norm((y - mu)^2, '2') / ((n - EDF)^2)

    # Update optimal lambda if current GCV is lower
    if (gcv < min_gcv) { min_gcv <- gcv
      optimal_lambda <- lambda
      beta_optimal <- Beta
      mu_optimal <- mu
      medf <- EDF } }

  optimal_tps <- list(beta = beta_optimal, mu = mu_optimal, medf = medf, lambda = seq(lsp[1], lsp[2], length.out = 100), gcv = min_gcv, xk = res_get$xk, Z = res_get$Z)
  class(optimal_tps) <- 'tps'

  return(optimal_tps) }

res_tps <- fitTPS(x, y)

plot.tps <- function(tps_object, plot_type = "persp", ...) {
  # Function: plot.tps
  # Purpose: This function plots a Thin Plate Spline (TPS) interpolation surface based on a given tps_object.
  # Parameters:
  # - tps_object: An object containing components used for TPS, typically generated by another function (e.g., getTPS).
  #   - It must include beta, xk, Z, and mu.
  # - plot_type: A string specifying the type of plot to create. Options include "persp" and "contour". Default is "persp".
  # - ... : Additional graphical parameters to pass to the plotting functions (persp or contour).
  # Returns:
  # - A plot of the TPS interpolation surface according to the specified plot_type.


  # Extract key components from the tps object
  beta <- tps_object$beta
  xk <- tps_object$xk
  Z <- tps_object$Z
  mu <- tps_object$mu

  # Compute alpha and delta using beta and Z
  alpha <- Z %*% beta[seq_len(ncol(Z))]
  delta <- beta[(ncol(Z) + 1):length(beta)]

  # Define grid points where you want to predict the surface
  grid_size <- 50
  x_seq <- seq(min(xk[, 1]), max(xk[, 1]), length.out = grid_size)
  y_seq <- seq(min(xk[, 2]), max(xk[, 2]), length.out = grid_size)
  grid_points <- expand.grid(x_seq, y_seq)

  # Explicitly make sure data types and dimensions are as expected
  grid_points <- as.matrix(grid_points)
  delta <- as.vector(delta)

  # Compute predicted values on the grid
  E_grid <- matrix(0, nrow = nrow(grid_points), ncol = nrow(xk))
  for (i in seq_len(nrow(grid_points))) { E_grid[i,] <- sapply(seq_len(nrow(xk)), function(j) eta(norm(as.matrix(grid_points[i,]) - xk[j,], '2'))) }

  # Now try the multiplication
  tryCatch({ predictions <- E_grid %*% alpha + cbind(1, grid_points) %*% delta }, warning = function(w) { print(paste("Warning: ", w$message)) }, error = function(e) { print(paste("Error: ", e$message))
    print("Check the dimensions and types of grid_points and delta.") })

  # Reshape for plotting
  predictions_matrix <- matrix(predictions, nrow = grid_size, ncol = grid_size)

  # Create the plot
  if (plot_type == "persp") { persp(x_seq, y_seq, predictions_matrix, ...) } else if (plot_type == "contour") { contour(x_seq, y_seq, predictions_matrix, ...) } }

plot(res_tps, plot_type = 'persp')
